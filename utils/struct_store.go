package utils

import (
	"bytes"
	"container/list"
	"encoding/binary"
	"reflect"
	"sort"

	"YJS-GO/structs"
)

var Clients = map[uint64]list.List{}
var _pendingClientStructRefs = map[uint64]PendingClientStructRef{}
var _pendingStack = list.New()

type StructStore struct {
	Clients                 map[uint64][]structs.IAbstractStruct
	PendingClientStructRefs map[uint64]*PendingClientStructRef
	PendingStack            *list.List
	PendingDeleteReaders    []*DSDecoderV2
}

func FindIndexSS(abstractStructs []structs.IAbstractStruct, clock uint64) uint {
	if len(abstractStructs) <= 0 {
		return 0
	}
	var left = 0
	var right = len(abstractStructs) - 1
	var mid = abstractStructs[right].(*structs.Item)
	var midClock = mid.Id.Clock

	if midClock == clock {
		return uint(right)
	}

	// @todo does it even make sense to pivot the search?
	// If a good split misses, it might actually increase the time to find the correct item.
	// Currently, the only advantage is that search with pivoting might find the item on the first try.
	midIndex := (int)((clock * uint64(right)) / (midClock + mid.Length - 1))

	for left <= right {
		mid = abstractStructs[midIndex].(*structs.Item)
		midClock = mid.Id.Clock

		if midClock <= clock {
			if clock < midClock+mid.Length {
				return uint(midIndex)
			}

			left = midIndex + 1
		} else {
			right = midIndex - 1
		}

		midIndex = (left + right) / 2
	}
	// Always check state before looking for a struct in StructStore
	// Therefore the case of not finding a struct is unexpected.
	return 0
}

type PendingClientStructRef struct {
	NextReadOperation int
	Refs              []structs.IAbstractStruct
}

// Return the states as a Map<int,int>.
// Note that Clock refers to the next expected Clock id.
func (s *StructStore) GetStateVector() map[uint64]uint64 {
	var result = map[uint64]uint64{}

	for k, v := range Clients {
		var str = v.Back().Value.(*structs.AbstractStruct)
		result[k] = str.Id.Clock + str.Length
	}
	return result
}

func (s *StructStore) MergeReadStructsIntoPendingReads(clientStructsRefs map[uint64][]structs.IAbstractStruct) {
	var pendingClientStructRefs = s.PendingClientStructRefs
	for client, structRefs := range clientStructsRefs {
		pendingStructRefs, ok := pendingClientStructRefs[client]
		if !ok {
			pendingStructRefs = &PendingClientStructRef{
				Refs: structRefs,
			}
		} else {
			if pendingStructRefs.NextReadOperation > 0 {
				pendingStructRefs.Refs = pendingStructRefs.Refs[pendingStructRefs.NextReadOperation:]
			}
			var merged = pendingStructRefs.Refs
			for i := 0; i < len(structRefs); i++ {
				merged = append(merged, structRefs[i])
			}
			sort.SliceStable(merged, func(i, j int) bool {
				return merged[i].ID().Clock < merged[j].ID().Clock
			})
			pendingStructRefs.NextReadOperation = 0
			pendingStructRefs.Refs = merged
		}
	}

}

// ResumeStructIntegration Resume computing structs generated by struct readers.
// While there is something to do, we integrate structs in this order:
// 1. Top element on stack, if stack is not empty.
// 2. Next element from current struct reader (if empty, use next struct reader).
// If struct causally depends on another struct (ref.missing), we put next reader of
// 'ref.id.client' on top of stack.
// At some point we find a struct that has no causal dependencies, then we start
// emptying the stack.
// It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
// depends on struct3 (from client1). Therefore, the max stack size is equal to 'structReaders.length'.
// This method is implemented in a way so that we can resume computation if this update causally
// depends on another update.
func (s *StructStore) ResumeStructIntegration(transaction *Transaction) {
	// @todo: Don't forget to append stackhead at the end.
	var stack = s.PendingStack
	var clientsStructRefs = s.PendingClientStructRefs
	if len(clientsStructRefs) == 0 {
		return
	}
	var getMapKeys = func(inputMap map[uint64]*PendingClientStructRef) (ret []uint64) {
		for k, _ := range inputMap {
			ret = append(ret, k)
		}
		return
	}
	// Sort them so that we take the higher id first,
	// in case of conflicts the lower id will probably not conflict with the id from the higher user.
	var clientsStructRefsIds = getMapKeys(clientsStructRefs)
	sort.SliceStable(clientsStructRefsIds, func(i, j int) bool {
		return clientsStructRefsIds[i] < clientsStructRefsIds[j]
	})
	var getNextStructTarget = func() *PendingClientStructRef {
		var nextStructsTarget = clientsStructRefs[clientsStructRefsIds[len(clientsStructRefsIds)-1]]
		for len(nextStructsTarget.Refs) == nextStructsTarget.NextReadOperation {
			clientsStructRefsIds = clientsStructRefsIds[0 : len(clientsStructRefsIds)-1]
			if len(clientsStructRefsIds) > 0 {
				nextStructsTarget = clientsStructRefs[clientsStructRefsIds[len(clientsStructRefsIds)-1]]
			} else {
				s.PendingClientStructRefs = map[uint64]*PendingClientStructRef{} // clear
				return nil
			}
		}
		return nextStructsTarget
	}
	var curStructsTarget = getNextStructTarget()
	if curStructsTarget == nil && stack.Len() == 0 {
		return
	}
	var stackHead structs.IAbstractStruct
	if stack.Len() > 0 {
		stackHead = stack.Back().Value.(structs.IAbstractStruct)
	} else {
		index := curStructsTarget.NextReadOperation
		stackHead = curStructsTarget.Refs[index]
		curStructsTarget.NextReadOperation++
	}
	// Caching the state because it is used very often.
	var state = map[uint64]uint64{}
	var (
		localClock uint64
		ok         bool
	)
	for {
		localClock, ok = state[stackHead.ID().Client]
		if !ok {
			localClock = s.GetState(stackHead.ID().Client)
			state[stackHead.ID().Client] = localClock
		}

		var offset uint64
		if stackHead.ID().Clock < localClock {
			offset = localClock - stackHead.ID().Clock
		}
		if stackHead.ID().Clock+offset != localClock {
			// A previous message from this client is missing.
			// Check if there is a pending structRef with a smaller clock and switch them.
			structRefs, ok := clientsStructRefs[stackHead.ID().Client]
			if !ok {
				structRefs = &PendingClientStructRef{}
			}

			if len(structRefs.Refs) != structRefs.NextReadOperation {
				var r = structRefs.Refs[structRefs.NextReadOperation]
				if r.ID().Clock < stackHead.ID().Clock {
					// Put ref with smaller clock on stack instead and continue.
					structRefs.Refs[structRefs.NextReadOperation] = stackHead
					stackHead = r

					// Sort the set because this approach might bring the list out of order.
					structRefs.Refs = structRefs.Refs[structRefs.NextReadOperation:]
					sort.SliceStable(structRefs.Refs, func(i, j int) bool {
						return structRefs.Refs[i].ID().Clock < structRefs.Refs[j].ID().Clock
					})
					structRefs.NextReadOperation = 0
					continue
				}
			}

			// Wait until missing struct is available.
			stack.PushBack(stackHead)
			return
		}
		missing, err := stackHead.GetMissing(transaction, s)
		if err != nil {
			if offset == 0 || offset < stackHead.GetLength() {
				stackHead.Integrate(transaction, int(offset))
				state[stackHead.ID().Client] = stackHead.ID().Clock + stackHead.GetLength()
			}

			// Iterate to next stackHead.
			if stack.Len() > 0 {
				stackHead = stack.Back().Value.(structs.IAbstractStruct)
			} else if curStructsTarget != nil && curStructsTarget.NextReadOperation < len(curStructsTarget.Refs) {
				index := curStructsTarget.NextReadOperation
				stackHead = curStructsTarget.Refs[index]
				curStructsTarget.NextReadOperation++
			} else {
				curStructsTarget = getNextStructTarget()
				if curStructsTarget == nil {
					// We are done!
					break
				} else {
					index := curStructsTarget.NextReadOperation
					stackHead = curStructsTarget.Refs[index]
					curStructsTarget.NextReadOperation++
				}
			}
		} else {
			// Get the struct reader that has the missing struct.
			structRefs, ok := clientsStructRefs[missing]
			if !ok {
				structRefs = &PendingClientStructRef{}
			}

			if len(structRefs.Refs) == structRefs.NextReadOperation {
				// This update message causally depends on another update message.
				stack.PushBack(stackHead)
				return
			}
			stack.PushBack(stackHead)
			index := structRefs.NextReadOperation
			stackHead = structRefs.Refs[index]
			structRefs.NextReadOperation++
		}
	}
	s.PendingClientStructRefs = map[uint64]*PendingClientStructRef{} // clear
}

func (s *StructStore) CleanupPendingStructs() {
	var clientsToRemove []uint64
	// Cleanup pendingCLientsStructs if not fully finished.
	for client, refs := range s.PendingClientStructRefs {

		if refs.NextReadOperation == len(refs.Refs) {
			clientsToRemove = append(clientsToRemove, client)
		} else {
			refs.Refs = refs.Refs[refs.NextReadOperation:]
			refs.NextReadOperation = 0
		}
	}
	if len(clientsToRemove) == 0 {
		return
	}
	for _, key := range clientsToRemove {
		delete(s.PendingClientStructRefs, key)
	}
}

func (s *StructStore) TryResumePendingDeleteReaders(transaction *Transaction) {
	var pendingReaders = s.PendingDeleteReaders
	s.PendingDeleteReaders = s.PendingDeleteReaders[:0] // 官方推荐使用nil,这里暂使用空切片
	for i := 0; i < len(pendingReaders); i++ {
		s.ReadAndApplyDeleteSet(pendingReaders[i], transaction)
	}
}

func (s *StructStore) GetState(c uint64) uint64 {
	ss, ok := s.Clients[c]
	if ok {
		lastStruct := ss[len(ss)-1].(*structs.Item)
		return lastStruct.Id.Clock + lastStruct.Length
	}
	return 0
}

func (s *StructStore) ReadAndApplyDeleteSet(decoder *DSDecoderV2, transaction *Transaction) {
	var unappliedDs = &DeleteSet{}
	numClients, err := binary.ReadUvarint(decoder.Reader())
	if err != nil {
		return
	}

	for i := 0; i < int(numClients); i++ {
		decoder.ResetDsCurVal()
		client, err := binary.ReadUvarint(decoder.Reader())
		if err != nil {
			return
		}
		numberOfDeletes, err := binary.ReadUvarint(decoder.Reader())
		if err != nil {
			return
		}
		strs, ok := s.Clients[client]
		if !ok {
			strs = []structs.IAbstractStruct{}
			// NOTE: Clients map is not updated.
		}

		var state = s.GetState(client)
		for deleteIndex := 0; deleteIndex < int(numberOfDeletes); deleteIndex++ {
			var clock = decoder.ReadDsClock()
			var clockEnd = clock + decoder.ReadDsLength()
			if clock < state {
				if state < clockEnd {
					unappliedDs.Add(client, state, clockEnd-state)
				}
				var index = FindIndexSS(strs, clock)
				// We can ignore the case of GC and Delete structs, because we are going to skip them.
				var str = strs[index]

				// Split the first item if necessary.
				if !str.GetDeleted() && str.ID().Clock < clock {
					var splitItem = str.(*structs.Item).SplitItem(transaction, clock-str.ID().Clock)
					strs = insert(strs, index, splitItem)
					// Increase, we now want to use the next struct.
					index++
				}
				for int(index) < len(strs) {
					str = strs[index]
					index++
					if str.ID().Clock < clockEnd {
						if !str.GetDeleted() {
							if clockEnd < str.ID().Clock+str.GetLength() {
								var splitItem = str.(*structs.Item).SplitItem(transaction, clockEnd-str.ID().Clock)
								strs = insert(strs, index, splitItem)
							}
							str.Delete(transaction)
						}
					} else {
						break
					}
				}
			} else {
				unappliedDs.Add(client, clock, clockEnd-clock)
			}
		}

	}
	if len(unappliedDs.Clients) > 0 {
		var unappliedDsEncoder = &DSEncoderV2{}
		// @TODO: No need for encoding+decoding ds anymore.
		unappliedDs.Write(unappliedDsEncoder)
		s.PendingDeleteReaders = append(s.PendingDeleteReaders, NewDsDecoderV2(bytes.NewReader(unappliedDsEncoder.ToArray())))
	}
}

func (s *StructStore) ReplaceStruct(oldStruct structs.IAbstractStruct, newStruct structs.IAbstractStruct) {
	structs, ok := s.Clients[oldStruct.ID().Client]
	if !ok {
		// throw new Exception();
		return
	}

	index := FindIndexSS(structs, oldStruct.ID().Clock)
	structs[index] = newStruct
}

func (s *StructStore) GetItemCleanEnd(transaction *Transaction, id *ID) structs.IAbstractStruct {
	strs, ok := s.Clients[id.Client]
	if !ok {
		// throw new Exception();
		return nil
	}
	index := FindIndexSS(strs, id.Clock)
	var str = strs[index]

	if id.Clock != str.ID().Clock+str.GetLength()-1 && reflect.TypeOf(str) != reflect.TypeOf(&structs.GC{}) {
		insert(strs, index+1, str.(*structs.Item).SplitItem(transaction, id.Clock-str.ID().Clock+1))
	}

	return str
}

func insert(arr []structs.IAbstractStruct, index uint, item *structs.Item) []structs.IAbstractStruct {
	if index > 0 && int(index) < len(arr) {
		arr = append(arr[:index+1], arr[index:]...)
		arr[index] = item
	} else if int(index) >= len(arr) {
		arr = append(arr, item)
	} else {
		arr = append([]structs.IAbstractStruct{item}, arr...)
	}

	return arr
}
